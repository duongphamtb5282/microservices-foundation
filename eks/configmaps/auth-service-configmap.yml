apiVersion: v1
kind: ConfigMap
metadata:
  name: auth-service-config
  namespace: auth-service-prod
  labels:
    app: auth-service
    service: auth-service
    environment: production
    # EKS specific labels
    app.kubernetes.io/name: auth-service
    app.kubernetes.io/component: authentication
    app.kubernetes.io/part-of: microservices
    app.kubernetes.io/managed-by: eks
spec:
  data:
    application-prod.yml: |
      spring:
        application:
          name: auth-service
        profiles:
          active: prod
        datasource:
          url: ${DB_URL}
          username: ${DB_USERNAME}
          password: ${DB_PASSWORD}
          driver-class-name: org.postgresql.Driver
          hikari:
            minimum-idle: 2
            maximum-pool-size: 10
            connection-timeout: 20000
            idle-timeout: 300000
            max-lifetime: 600000
            pool-name: AuthServiceHikariPool
        jpa:
          hibernate:
            ddl-auto: validate
            show-sql: false
            properties:
              hibernate:
                dialect: org.hibernate.dialect.PostgreSQLDialect
                format_sql: true
                default_schema: auth
                jdbc:
                  batch_size: 20
                  order_inserts: true
                  order_updates: true
        redis:
          host: ${REDIS_HOST}
          port: ${REDIS_PORT}
          timeout: 2000ms
          lettuce:
            pool:
              max-active: 8
              max-idle: 8
              min-idle: 0

      keycloak:
        server:
          url: ${KEYCLOAK_URL}
          realm: microservices
          client-id: auth-service
          client-secret: ${KEYCLOAK_CLIENT_SECRET}

      management:
        endpoints:
          web:
            exposure:
              include: health,info,metrics,prometheus
        metrics:
          export:
            prometheus:
              enabled: true
        endpoint:
          health:
            show-details: when_authorized

      # Resilience4j configuration
      resilience4j:
        circuitbreaker:
          instances:
            database:
              failure-rate-threshold: 50
              wait-duration-in-open-state: 30s
              sliding-window-size: 10
              minimum-number-of-calls: 5
            redis:
              failure-rate-threshold: 60
              wait-duration-in-open-state: 20s
              sliding-window-size: 8
        retry:
          instances:
            database:
              max-attempts: 3
              wait-duration: 1s
              exponential-backoff-multiplier: 2
            external-api:
              max-attempts: 2
              wait-duration: 500ms
        timelimiter:
          instances:
            default:
              timeout-duration: 10s

      # Tracing configuration
      spring:
        sleuth:
          sampler:
            probability: 0.1
          zipkin:
            base-url: ${SPRING_ZIPKIN_BASE_URL}
        cloud:
          loadbalancer:
            retry:
              enabled: true
              max-retries-on-same-service-instance: 1
              max-retries-on-next-service-instance: 2

      # Cache configuration
      spring:
        cache:
          type: redis
          redis:
            time-to-live: 600000
            cache-null-values: false

      logging:
        level:
          root: INFO
          com.pacific.auth: INFO
          org.springframework.security: WARN
          org.springframework.web: WARN
          org.hibernate.SQL: WARN
          org.hibernate.type.descriptor.sql.BasicBinder: WARN
        pattern:
          console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{traceId:-},%X{spanId:-}] %logger{36} - %msg%n"
          file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{traceId:-},%X{spanId:-}] %logger{36} - %msg%n"
